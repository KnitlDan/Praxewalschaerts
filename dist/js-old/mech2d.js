(()=>{"use strict";class t{static args=(...t)=>{if(0==t.length)return null;for(var n=t[0],i=[],s=!1,a=!1,o=0,c=0,l=1;l<t.length;l++){if(null===(u=r(t[l])))throw"unknown argument definition";if(s)throw"only the last argument is allowed to be variadic";if(c++,"default"in u)a=!0;else if(u.variadic||o++,a)throw"default arguments needs to be at the end of the argument list";u.variadic&&(s=!0),i.push(u)}if(s&&(c=n.length),n.length<o)return null;if(null!==c&&n.length>c)return null;var h={};for(l=0;l<i.length;l++){var u;if((u=i[l]).variadic)if(l<n.length){for(var g=[],m=l;m<n.length;m++){if(!e(u,n[m]))return null;g.push(n[m])}h[u.name]=g}else h[u.name]="default"in u?u.default:[];else if(l<n.length){if(g=n[l],!e(u,g))return null;h[u.name]=g}else h[u.name]=u.default}return h}}const e=(t,e)=>{if("type"in t){var n=typeof t.type;if("string"===n){if(typeof e!==t.type)return!1}else{if("function"!==n)return!1;if(!(e instanceof t.type))return!1}}return!("check"in t&&!(0,t.check)(e))},n=t=>{for(var e=[],r=0;r<t.length;r++){var i=t[r];if("string"==typeof i)for(var s=i.split(/:/),a=0;a<s.length;a++)""!==s[a]&&e.push(s[a]);else if(i instanceof Array){var o=n(i);for(a=0;a<o.length;a++)e.push(o[a])}else e.push(i)}return e},r=t=>{if("string"==typeof t&&(t=[t]),t instanceof Array&&(t=(t=>{if((t=n(t)).length<1)throw"invalid argument description: description too short";if("string"!=typeof t[0])throw"invalid argument description: missing name";var e="type",r={},i=!1;r.name=t[0],r.variadic=!1;for(var s=1;s<t.length;s++){var a=t[s];if("string"!=typeof a||i){if(e in r)throw"invalid argument description: "+e+" already defined";if("check"===e&&"function"!=typeof a)throw"invalid argument description";r[e]=a,i=!1}else if("variadic"===a)r.variadic=!0;else if("check"===a||"type"===a||"default"===a)e=a,i=!0;else{if("type"in r)throw"invalid argument description: type already defined";r.type=a}}return r})(t)),"object"!=typeof t)throw"invalid argument";if(t.variadic="variadic"in t&&!!t.variadic,!("name"in t))throw"each argument needs a name";if("string"!=typeof t.name)throw"argument names needs to be strings";return t};class i{static isZero=t=>0==t||Math.abs(t)<s;static isEqual=(t,e)=>this.isZero(t-e)}var s=1e-13;class a{static getName=()=>{throw"This method is abstract"};static accepts=t=>!0;static parse=(t,e,n)=>{throw"This method is abstract"};static toString=(t,e,n)=>{throw"This method is abstract"}}class o{constructor(t){if(!(t instanceof RegExp))return new c(t);var e,n,r;e="("+t.source+")(.*)$",n="("+t.source+")$",r=t.flags.replace(/[gs]/,""),this.readTokenPattern=new RegExp("^"+e,r),this.splitPattern=new RegExp(e,r),this.trimToken=new RegExp(n,r)}split2=t=>{var e=t.match(this.splitPattern);return e?[t.replace(this.splitPattern,""),e[e.length-1]]:[t]};readToken=t=>{var e=t.match(this.readTokenPattern);return e?[e[1],e[e.length-1]]:[null,t]};readTokenFromEnd=t=>{var e=t.match(this.trimToken);return e?[e[1],t.replace(this.trimToken,"")]:[null,t]};trim=t=>{var e;return[e,t]=this.readToken(t),[e,t]=this.readTokenFromEnd(t),t};matchAll=t=>{var e=this.readToken(t);return null!==e[0]&&""===e[1]}}class c{constructor(t){if("string"!=typeof t)throw"cannot create a string matching pattern from non-string";this.pattern=t}split2=t=>{var e=t.indexOf(this.pattern);return e<0?[t]:[t.substr(0,e),t.substr(e+this.pattern.length)]};readToken=t=>t.substr(0,this.pattern.length)===this.pattern?[this.pattern,t.substr(this.pattern.length)]:[null,t];readTokenFromEnd=t=>t.length>this.pattern.length&&t.substr(t.length-this.pattern.length,this.pattern.length)===this.pattern?[this.pattern,t.substr(0,t.length-this.pattern.length)]:[null,t];trim=t=>{var e;return[e,t]=this.readToken(t),[e,t]=this.readTokenFromEnd(t),t};matchAll=t=>{var e=this.readToken(t);return null!==e[0]&&""===e[1]}}class l extends a{static getName=()=>"number";static accepts=t=>"number"==typeof t;static parse=(t,e,n)=>{t=new o(e.get("number.input.space")).trim(t);var r=Number(t);if(isNaN(r)&&!isFinite(r))throw"Cannot parse number";return r};static toString=(t,e,n)=>{var r=e.get("number.output.precision");if(null!==r){var i=e.get("number.output.outputZeroTrailingDecimals");t=t.toFixed(r),i||(t=t.replace(/\.?0+$/,""))}return""+t}}class h extends a{static parse(t,e,n){var r=this.parseStringCouple(t,e);if(null===r)throw"cannot parse "+this.getName();return r=r.map((t=>e.invokeParse(l,t))),this.coupleToObject(r)}static parseStringCouple(t,e){var n,r=this.getName(),i=new o(e.get(r+".input.space")),s=new o(e.get(r+".input.delimeter")),a=e.get(r+".input.parenthesis").map((t=>new o(t)));if(t=i.trim(t),[n,t]=a[0].readToken(t),null===n)return null;if([n,t]=a[1].readTokenFromEnd(t),null===n)return null;t=i.trim(t);var c=s.split2(t);return 2!=c.length||1!=s.split2(c[1]).length?null:c.map((t=>i.trim(t)))}static toString(t,e,n){var r=this.objectToCouple(t),i=e.get(this.getName()+".output.delimeter"),s=e.get(this.getName()+".output.parenthesis");return""+s[0]+e.invokeToString(l,r[0])+i+e.invokeToString(l,r[1])+s[1]}}class u{constructor(t,e){this.x=t,this.y=e,Object.freeze(this)}static create=(...e)=>{var n;if(n=t.args(e,"x:number","y:number"))return new u(n.x,n.y);if(n=t.args(e,["point",u]))return n.point;if(n=t.args(e,"string:string"))return X.get().parsePoint(n.string);throw"Cannot construct vector from given arguments"};static origin=()=>new u(0,0);rot=(t,e)=>{if(t instanceof u&&(t=this.vectorTo(t)),!t instanceof S)throw"invalid argument: needs to rotate a vector or a point";return this.addVector(t.rot(e))};addVector=t=>new u(this.x+t.x,this.y+t.y);distanceTo=t=>this.vectorTo(t).size();vectorTo=t=>{var e=t.x-this.x,n=t.y-this.y;return new S(e,n)};isOrigin=()=>i.isZero(this.x)&&i.isZero(this.y);toString=(...t)=>X.get.apply(X,t).pointToString(this)}class g extends h{static getName=()=>"point";static accepts=t=>t instanceof u;static coupleToObject=t=>new u(t[0],t[1]);static objectToCouple=t=>[t.x,t.y]}class m extends h{static getName=()=>"vector";static accepts=t=>t instanceof S;static coupleToObject=t=>new S(t[0],t[1]);static objectToCouple=t=>[t.x,t.y]}var f={};class d{static register(t){if(!t instanceof d)throw"Cannot register an object not being an instance of AtomicTransformation";var e=t.getName();if(e in f)throw"Atomic transformation of name '"+e+"' is already defined";f[e]=t}static getAtomicTransformationClassByType(t){if(!t in f)throw"Unknown atomic transformation: "+t;return f[t]}static instantiate(t){if(!1 in t)throw"missing field: type";return new(this.getAtomicTransformationClassByType(t.type))(t)}static getName(){throw"This method is abstract"}static getArgsConvertors(){throw"This method is abstract"}static getNonCanonicalArgsConvertors(){return this.getArgsConvertors()}static argsToParams(t){throw"This method is abstract"}static nonCanonicalArgsToParams(t){return this.argsToParams(t)}getCanonizedTransformations(){return this.isCanonical()?[this]:this.getNonCanonicalToCanonizedTransformations()}getNonCanonicalToCanonizedTransformations(){return[d.instantiate({type:"matrix",matrix:this.getMatrix()})]}getShiftTransformations(t,e){var n=u.origin().vectorTo(e),r={type:"translate",vector:n.mul(-1)},i={type:"translate",vector:n};return[d.instantiate(r),d.instantiate(t),d.instantiate(i)]}getClass(){return this.constructor}getName(){return this.getClass().getName()}getArgsConvertors(){return this.getClass().getArgsConvertors()}getNonCanonicalArgsConvertors(){return this.getClass().getNonCanonicalArgsConvertors()}getArgs(){throw"This method is abstract"}isIdentity(){throw"This method is abstract"}getNonCanonicalArgs(){return this.getArgs()}canonicalMerge(t){return null}_checkParam(t,e,n){if(!e in t)throw"expected param "+e;if("string"==typeof n){if(typeof t[e]!==n)throw e+" is expected to be "+n+", "+typeof t[e]+" given"}else if(!t[e]instanceof n)throw e+" has invalid type"}}class p{static create=(t,e,n,r,i,s)=>new p(t,e,n,r,i,s);constructor(t,e,n,r,i,s){this.m=[[t,n,i],[e,r,s],[0,0,1]],Object.freeze(this),Object.freeze(this.m),Object.freeze(this.m[0]),Object.freeze(this.m[1])}data(){return[this.m[0][0],this.m[1][0],this.m[0][1],this.m[1][1],this.m[0][2],this.m[1][2]]}inv=()=>{var t=[this.m[0].concat([1,0,0]),this.m[1].concat([0,1,0]),this.m[2].concat([0,0,1])];const e=(e,n)=>{for(var r=0;r<6;r++)t[e][r]=t[e][r]*n},n=(e,n,r)=>{for(var i=0;i<6;i++)t[e][i]+=t[n][i]*r};return Math.abs(t[0][0])<Math.abs(t[1][0])&&(()=>{for(var e,n=0;n<6;n++)e=t[0][n],t[0][n]=t[1][n],t[1][n]=e})(),n(1,2,-t[1][2]),n(0,2,-t[0][2]),e(0,1/t[0][0]),n(1,0,-t[1][0]),e(1,1/t[1][1]),n(0,1,-t[0][1]),new p(t[0][3],t[1][3],t[0][4],t[1][4],t[0][5],t[1][5])};mul=t=>{if("number"==typeof t)return new p(this.m[0][0]*args.scalar,this.m[1][0]*t,this.m[0][1]*args.scalar,this.m[1][1]*t,this.m[0][2]*args.scalar,this.m[1][2]*t);if(t instanceof p){var e=this;const n=(n,r)=>{for(var i=0,s=0;s<3;s++)i+=e.m[n][s]*t.m[s][r];return i};return new p(n(0,0),n(1,0),n(0,1),n(1,1),n(0,2),n(1,2))}throw"invalid arguments"};add=t=>new p(this.m[0][0]+t.m[0][0],this.m[1][0]+t.m[1][0],this.m[0][1]+t.m[0][1],this.m[1][1]+t.m[1][1],this.m[0][2]+t.m[0][2],this.m[1][2]+t.m[1][2]);sub=t=>new p(this.m[0][0]-t.m[0][0],this.m[1][0]-t.m[1][0],this.m[0][1]-t.m[0][1],this.m[1][1]-t.m[1][1],this.m[0][2]-t.m[0][2],this.m[1][2]-t.m[1][2]);det=()=>this.m[0][0]*this.m[1][1]-this.m[0][1]*this.m[1][0];isRegular=()=>!i.isZero(this.det());isSingular=()=>i.isZero(this.det());_transform=t=>{var e=this;const n=n=>{for(var r=0,i=0;i<3;i++)r+=e.m[n][i]*t[i];return r};return[n(0),n(1)]};transformPoint=t=>{var e=this._transform([t.x,t.y,1]);return new u(e[0],e[1])};transformVector=t=>{var e=this._transform([t.x,t.y,0]);return new S(e[0],e[1])}}class v{static translate=t=>new p(1,0,0,1,t.x,t.y);static rotate=(t,e=u.origin())=>{var n=new p(t.cos(),t.sin(),-t.sin(),t.cos(),0,0);return this._moveCenter(n,e)};static scale=(t,e,n=u.origin())=>{var r=new p(t,0,0,e,0,0);return this._moveCenter(r,n)};static skewX=(t,e=u.origin())=>{var n=new p(1,t.tan(),0,1,0,0);return this._moveCenter(n,e)};static skew=(t,e,n=u.origin())=>{var r=new p(1,t.tan(),e.tan(),1,0,0);return this._moveCenter(r,n)};static skewY=(t,e=u.origin())=>{var n=new p(1,0,t.tan(),1,0,0);return this._moveCenter(n,e)};static _moveCenter=(t,e=u.origin())=>{if(null!==e){var n=u.origin().vectorTo(e);if(!n.isZero()){var r=this.translate(n),i=this.translate(n.mul(-1));t=r.mul(t).mul(i)}}return t};static identity=()=>new p(1,0,0,1,0,0)}class w extends d{constructor(t){super(),this._checkParam(t,"vector",S),this.vector=t.vector}getMatrix(){return v.translate(this.vector)}getArgs(){return[this.vector.x,this.vector.y]}isIdentity(){return this.vector.isZero()}isCanonical(){return!0}static getName(){return"translate"}static getArgsConvertors(){return[l,l]}static argsToParams(t){var e,n;if(t.length<1||t.length>3)throw"Invalid number of arguments for a translation";return e=t[0],n=t.length>=2?t[1]:0,{vector:new S(e,n)}}canonicalMerge(t){return t instanceof w?new w({vector:this.vector.add(t.vector)}):null}}d.register(class extends d{constructor(t){super(),this._checkParam(t,"matrix",p),this.matrix=t.matrix}getMatrix(){return this.matrix}getArgs(){return[this.matrix.m[0][0],this.matrix.m[1][0],this.matrix.m[0][1],this.matrix.m[1][1],this.matrix.m[0][2],this.matrix.m[1][2]]}isIdentity(){}isCanonical(){return!0}static getName(){return"matrix"}static getArgsConvertors(){return[l,l,l,l,l,l]}static argsToParams(t){if(6!=t.length)throw"Invalid number of arguments for a matrix transformation";return{matrix:new p(t[0],t[1],t[2],t[3],t[4],t[5])}}}),d.register(class extends d{constructor(t){super(),this._checkParam(t,"angle",C),this._checkParam(t,"centerPoint",u),this.angle=t.angle,this.centerPoint=t.centerPoint}getMatrix(){return v.rotate(this.angle,this.centerPoint)}getArgs(){return this.centerPoint.isOrigin()?[this.angle]:[this.angle,this.centerPoint.x,this.centerPoint.y]}isIdentity(){return this.angle.normalize().isZero()}isCanonical(){return!0}static getName(){return"rotate"}static getArgsConvertors(){return[x,l,l]}static argsToParams(t){var e,n,r;if(t.length<1||t.length>3||2==t.length)throw"Invalid number of arguments for a rotation";return r=t[0],e=t.length>=2?t[1]:0,n=t.length>=3?t[2]:0,{angle:r,centerPoint:new u(e,n)}}}),d.register(class extends d{constructor(t){super(),this._checkParam(t,"scaleX","number"),this._checkParam(t,"scaleY","number"),this._checkParam(t,"centerPoint",u),this.scaleX=t.scaleX,this.scaleY=t.scaleY,this.centerPoint=t.centerPoint}getNonCanonicalToCanonizedTransformations(){return this.getShiftTransformations({type:"scale",scaleX:this.scaleX,scaleY:this.scaleY,centerPoint:u.origin()},this.centerPoint)}getMatrix(){return v.scale(this.scaleX,this.scaleY,this.centerPoint)}getArgs(){if(!this.centerPoint.isOrigin())throw"cannot get arguments for a scale with center point being different from origin";return i.isEqual(this.scaleX,this.scaleY)?[this.scaleX]:[this.scaleX,this.scaleY]}getNonCanonicalArgs(){return[this.scaleX,this.scaleY,this.centerPoint.x,this.centerPoint.y]}isIdentity(){return i.isEqual(this.scaleX,1)&&i.isEqual(this.scaleY,1)}isCanonical(){return this.centerPoint.isOrigin()}static getName(){return"scale"}static getArgsConvertors(){return[l,l]}static getNonCanonicalArgsConvertors(){return[l,l,l,l]}static argsToParams(t){return this._argsToParams(t,!0)}static nonCanonicalArgsToParams(t){return this._argsToParams(t,!1)}static _argsToParams(t,e){var n;if(e){if(t.length<1||t.length>2)throw"Invalid number of arguments for a scale transformation"}else if(t.length<1||3==t.length||t.length>4)throw"Invalid number of arguments for a scale transformation";return{scaleX:n=t[0],scaleY:t.length>=2?t[1]:n,centerPoint:4==t.length?new u(t[2],t[3]):u.origin()}}}),d.register(class extends d{constructor(t){super(),this._checkParam(t,"skewX",C),this._checkParam(t,"skewY",C),this._checkParam(t,"centerPoint",u),this.skewX=t.skewX,this.skewY=t.skewY,this.centerPoint=t.centerPoint}getNonCanonicalToCanonizedTransformations(){return this.getShiftTransformations({type:"skew",skewX:this.skewX,skewY:this.skewY,centerPoint:u.origin()},this.centerPoint)}getMatrix(){return v.skew(this.skewX,this.skewY,this.centerPoint)}getNonCanonicalArgs(){return[this.skewX,this.skewY,this.centerPoint.x,this.centerPoint.y]}getArgs(){if(!this.centerPoint.isOrigin())throw"cannot get arguments for a skew with center point being different from origin";return this.skewY.isZero()?[this.skewX]:[this.skewX,this.skewY]}isIdentity(){return this.skewX.normalize().isZero()&&this.skewY.normalize().isZero()}isCanonical(){return this.centerPoint.isOrigin()}static getName(){return"skew"}static getArgsConvertors(){return[x,x]}static getNonCanonicalArgsConvertors(){return[x,x,l,l]}static argsToParams(t){return this._argsToParams(t,!0)}static nonCanonicalArgsToParams(t){return this._argsToParams(t,!1)}static _argsToParams(t,e){if(e){if(t.length<1||t.length>2)throw"Invalid number of arguments for a skew transformation"}else if(t.length<1||3==t.length||t.length>4)throw"Invalid number of arguments for a skew transformation";return{skewX:t[0],skewY:t.length>=2?t[1]:C.zero(),centerPoint:4==t.length?new u(t[2],t[3]):u.origin()}}}),d.register(class extends d{constructor(t){super(),this._checkParam(t,"skewX",C),this._checkParam(t,"centerPoint",u),this.skewX=t.skewX,this.centerPoint=t.centerPoint}getNonCanonicalToCanonizedTransformations(){return this.getShiftTransformations({type:"skewX",skewX:this.skewX,centerPoint:u.origin()},this.centerPoint)}getMatrix(){return v.skew(this.skewX,C.zero(),this.centerPoint)}getNonCanonicalArgs(){return[this.skewX,this.centerPoint.x,this.centerPoint.y]}getArgs(){if(!this.centerPoint.isOrigin())throw"cannot get arguments for a skewX with center point being different from origin";return[this.skewX]}isIdentity(){return this.skewX.normalize().isZero()}isCanonical(){return this.centerPoint.isOrigin()}static getName(){return"skewX"}static getArgsConvertors(){return[x]}static getNonCanonicalArgsConvertors(){return[x,l,l]}static argsToParams(t){return this._argsToParams(t,!0)}static nonCanonicalArgsToParams(t){return this._argsToParams(t,!1)}static _argsToParams(t,e){if(e){if(1!=t.length)throw"Invalid number of arguments for a skewX transformation"}else if(1!=t.length&&3!=t.length)throw"Invalid number of arguments for a skewX transformation";return{skewX:t[0],centerPoint:3==t.length?new u(t[1],t[2]):u.origin()}}}),d.register(class extends d{constructor(t){super(),this._checkParam(t,"skewY",C),this._checkParam(t,"centerPoint",u),this.skewY=t.skewY,this.centerPoint=t.centerPoint}getNonCanonicalToCanonizedTransformations(){return this.getShiftTransformations({type:"skewY",skewY:this.skewY,centerPoint:u.origin()},this.centerPoint)}getMatrix(){return v.skew(C.zero(),this.skewY,this.centerPoint)}getNonCanonicalArgs(){return[this.skewY,this.centerPoint.x,this.centerPoint.y]}getArgs(){if(!this.centerPoint.isOrigin())throw"cannot get arguments for a skewY with center point being different from origin";return[this.skewY]}isIdentity(){return this.skewY.normalize().isZero()}isCanonical(){return this.centerPoint.isOrigin()}static getName(){return"skewY"}static getArgsConvertors(){return[x]}static getNonCanonicalArgsConvertors(){return[x,l,l]}static argsToParams(t){return this._argsToParams(t,!0)}static nonCanonicalArgsToParams(t){return this._argsToParams(t,!1)}static _argsToParams(t,e){if(e){if(1!=t.length)throw"Invalid number of arguments for a skewY transformation"}else if(1!=t.length&&3!=t.length)throw"Invalid number of arguments for a skewY transformation";return{skewY:t[0],centerPoint:3==t.length?new u(t[1],t[2]):u.origin()}}}),d.register(w);const k=d;var y={skew:"skew",skewX:"skew",skewY:"skew",canonical:"canonical",noncanonical:"canonical"},T={skew:"skew",canonical:"noncanonical"};class P{constructor(){this.skewMode="skew",this.centerPoint=u.origin(),this.nonCanonicalCenterPoint=this.centerPoint}parseMode=t=>{var e={},n=Object.assign({},T);t=null===t?[]:t.split(/\s*,\s*/);for(var r=0;r<t.length;r++)if(""!=t[r]){if(!t[r]in y)throw"unknown decomposition mode: "+t[r];var i=y[t[r]];if(i in e)throw"mode already set: "+t[r];e[i]=!0,n[i]=t[r]}return n};setParams=(...e)=>{var n,r,i;if(n=t.args(e))r=null,i=null;else if(n=t.args(e,["centerPoint",u,"default",null],["mode","string","default",null]))r=n.centerPoint,i=n.mode;else{if(!(n=t.args(e,["mode","string","default",null])))throw"Cannot decompose according to given params";r=null,i=n.mode}i=this.parseMode(i),null===r&&(r=u.origin()),this.skewMode=i.skew,this.centerPoint=r,"noncanonical"==i.canonical?this.nonCanonicalCenterPoint=r:this.nonCanonicalCenterPoint=u.origin()};decompose=t=>{var e,n,r=[],i=new S(1,0),s=new S(0,1);if(t.isRegular()){if(e=t.transformVector(i),n=t.transformVector(s),"skew"===this.skewMode){var a=C.atan(e.mul(n)/n.mul(n));r.unshift({type:"skew",skewX:a,skewY:C.zero(),centerPoint:this.nonCanonicalCenterPoint}),t=t.mul(v.skew(a.mul(-1),C.zero(),this.nonCanonicalCenterPoint))}else if("skewX"===this.skewMode)a=C.atan(e.mul(n)/n.mul(n)),r.unshift({type:"skewX",skewX:a,centerPoint:this.nonCanonicalCenterPoint}),t=t.mul(v.skewX(a.mul(-1),this.nonCanonicalCenterPoint));else{var o=C.atan(e.mul(n)/e.mul(e));r.unshift({type:"skewY",skewY:o,centerPoint:this.nonCanonicalCenterPoint}),t=t.mul(v.skewY(o.mul(-1),this.nonCanonicalCenterPoint))}e=t.transformVector(i),n=t.transformVector(s);var c=e.size(),l=n.size();e.rot(C.right()).mul(n)<0&&(l=-l),r.unshift({type:"scale",scaleX:c,scaleY:l,centerPoint:this.nonCanonicalCenterPoint}),e=(t=t.mul(v.scale(1/c,1/l,this.nonCanonicalCenterPoint))).transformVector(i);var h=i.angleTo(e);r.unshift({type:"rotate",angle:h,centerPoint:this.centerPoint}),t=t.mul(v.rotate(h.mul(-1),this.centerPoint));var u=this.centerPoint.vectorTo(t.transformPoint(this.centerPoint));r.unshift({type:"translate",vector:u})}else r.unshift({type:"matrix",matrix:t});return r}}class b{constructor(t){this.atomicTransformations=[...t],this.atomicTransformations.length>0?this.matrix=this.atomicTransformations[0].getMatrix():this.matrix=v.identity();for(var e=1;e<this.atomicTransformations.length;e++)this.matrix=this.matrix.mul(this.atomicTransformations[e].getMatrix());Object.freeze(this),Object.freeze(this.atomicTransformations)}static create=(...e)=>{var n;if(n=t.args(e,["atomicTransformations",Array])){for(var r=0;r<n.atomicTransformations.length;r++)if(!n.atomicTransformations[r]instanceof k)throw"Cannot construct a transformation from given arguments";return new b(n.atomicTransformations)}if(n=t.args(e,["transformation",b]))return n.transformation;if(n=t.args(e,"string:string"))return X.get().parseTransformation(n.string);if(n=t.args(e,["matrix",p]))return b.matrix(n.matrix);if(n=t.args(e,"a:number","b:number","c:number","d:number","e:number","f:number")){var i=new p(n.a,n.b,n.c,n.d,n.e,n.f);return b.matrix(i)}throw"Cannot construct a transformation from given arguments"};static matrix=(...e)=>{var n,r;if(n=t.args(e,["matrix",p]))r=n.matrix;else{if(!(n=t.args(e,"a:number","b:number","c:number","d:number","e:number","f:number")))throw"Cannot construct a matrix transformation from the given arguments";r=new p(n.a,n.b,n.c,n.d,n.e,n.f)}var i=k.instantiate({type:"matrix",matrix:r});return new b([i])};static translate=(...e)=>{var n,r;if(n=t.args(e,["v",S]))r=n.v;else{if(!(n=t.args(e,"x:number",["y","number","default",0])))throw"Cannot construct a translation transformation from the given arguments";r=new S(n.x,n.y)}var i=k.instantiate({type:"translate",vector:r});return new b([i])};static rotate=(...e)=>{var n,r,i;if(n=t.args(e,["angle",C],["center",u,"default",null]))r=n.angle,i=n.center;else if(n=t.args(e,["angle",C],"cx:number",["cy","number","default",0]))r=n.angle,i=new u(n.cx,n.cy);else if(n=t.args(e,"angle:number",["center",u,"default",null]))r=C.create(n.angle),i=n.center;else{if(!(n=t.args(e,"angle:number","cx:number",["cy","number","default",0])))throw"Cannot construct a rotation transformation from the given arguments";r=C.create(n.angle),i=new u(n.cx,n.cy)}null===i&&(i=u.origin());var s=k.instantiate({type:"rotate",centerPoint:i,angle:r});return new b([s])};static scale=(...e)=>{var n,r,i,s;if(n=t.args(e,"a:number",["b","number","default",null],["center",u,"default",null]))r=n.a,i=null===n.b?n.a:n.b,s=n.center;else{if(!(n=t.args(e,"a:number",["center",u,"default",null])))throw"Cannot construct a scale transformation from the given arguments";r=n.a,i=n.a,s=n.center}null===s&&(s=u.origin());var a=k.instantiate({type:"scale",centerPoint:s,scaleX:r,scaleY:i});return new b([a])};static skewX=(...e)=>{var n,r,i;if(n=t.args(e,"angle:number",["center",u,"default",null]))r=new C(n.angle),i=n.center;else{if(!(n=t.args(e,["angle",C],["center",u,"default",null])))throw"Cannot construct a skewX transformation from the given arguments";r=n.angle,i=n.center}null===i&&(i=u.origin());var s=k.instantiate({type:"skewX",centerPoint:i,skewX:r});return new b([s])};static skewY=(...e)=>{var n,r,i;if(n=t.args(e,"angle:number",["center",u,"default",null]))r=new C(n.angle),i=n.center;else{if(!(n=t.args(e,["angle",C],["center",u,"default",null])))throw"Cannot construct a skewY transformation from the given arguments";r=n.angle,i=n.center}null===i&&(i=u.origin());var s=k.instantiate({type:"skewY",centerPoint:i,skewY:r});return new b([s])};static skew=(...e)=>{var n,r,i,s;if(n=t.args(e,["skewX",C],["skewY",C,"default",null],["center",u,"default",null]))r=n.skewX,i=n.skewY,s=n.center;else if(n=t.args(e,"skewX:number",["skewY","number","default",0],["center",u,"default",null]))r=new C(n.skewX),i=new C(n.skewY),s=n.center;else if(n=t.args(e,["skewX",C],["center",u,"default",null]))r=n.skewX,i=C.zero(),s=n.center;else{if(!(n=t.args(e,"skewX:number",["center",u,"default",null])))throw"Cannot construct a skew transformation from the given arguments";r=new C(n.skewX),i=C.zero(),s=n.center}null===s&&(s=u.origin()),null===i&&(i=C.zero());var a=k.instantiate({type:"skew",centerPoint:s,skewX:r,skewY:i});return new b([a])};static identity=()=>new b([]);getAtomicTransformations=()=>this.atomicTransformations;getMatrix=()=>this.matrix;compose=t=>b.matrix(this.getMatrix().mul(t.getMatrix()));concat=t=>new b(this.atomicTransformations.concat(t.atomicTransformations));join=t=>new b(this.atomicTransformations.concat(t.atomicTransformations));flatten=()=>b.matrix(this.getMatrix());inv=()=>b.matrix(this.getMatrix().inv());transformPoint=t=>this.getMatrix().transformPoint(t);transformVector=t=>this.getMatrix().transformVector(t);transform=t=>{if(t instanceof u)return this.transformPoint(t);if(t instanceof S)return this.transformVector(t);throw"Invalid argument"};decompose=(...t)=>{var e=new P;e.setParams(...t);var n=e.decompose(this.getMatrix()).map((t=>k.instantiate(t)));return new b(n)};canonize=()=>{for(var t=[],e=!0,n=0;n<this.atomicTransformations.length;n++)for(var r=this.atomicTransformations[n].getCanonizedTransformations(),i=0;i<r.length;i++)if(!r[i].isIdentity())if(e)t.push(r[i]),e=!1;else{var s=t[t.length-1].canonicalMerge(r[i]);null!==s?s.isIdentity()?t.pop():t[t.length-1]=s:t.push(r[i])}return e&&t.push(k.instantiate({type:"translate",vector:S.zero()})),new b(t)};toString=(...t)=>X.get.apply(X,t).transformationToString(this)}class C{constructor(t){this.radians=t,Object.freeze(this)}static create=(...e)=>{var n;if(n=t.args(e,"radians:number"))return new C(n.radians);if(n=t.args(e,["angle",C]))return n.angle;if(n=t.args(e,"string:string"))return X.get().parseAngle(n.string);throw"Cannot construct an angle from given arguments"};static zero=()=>new C(0);static full=()=>new C(2*Math.PI);static straight=()=>new C(Math.PI);static right=()=>new C(Math.PI/2);static rad=t=>new C(t);static deg=t=>new C(t*Math.PI/180);static grad=t=>new C(t*Math.PI/200);static turn=t=>new C(2*t*Math.PI);static atan=t=>new C(Math.atan(t));rad=()=>this.radians;deg=()=>180*this.radians/Math.PI;grad=()=>200*this.radians/Math.PI;turn=()=>this.radians/(2*Math.PI);mul=t=>new C(this.radians*t);add=t=>(t instanceof C||(t=C.create(t)),new C(this.radians+t.radians));sub=t=>(t instanceof C||(t=C.create(t)),new C(this.radians-t.radians));normalize=()=>{if(this.radians<0){var t=Math.ceil(-this.radians/(2*Math.PI));return new C(this.radians+2*t*Math.PI)}return this.radians>=2*Math.PI?(t=Math.floor(this.radians/(2*Math.PI)),new C(this.radians-2*t*Math.PI)):this};sin=()=>Math.sin(this.radians);cos=()=>Math.cos(this.radians);tan=()=>Math.tan(this.radians);cotan=()=>this.cos()/this.sin();getRotation=(t=u.origin())=>b.rotate(this,t);isZero=()=>i.isZero(this.radians);toString=(...t)=>X.get.apply(X,t).angleToString(this)}class x extends a{static getName=()=>"angle";static accepts=t=>t instanceof C;static getAllAvailableUnits=()=>["deg","rad","grad","turn"];static parse=(t,e,n)=>{var r,i=new o(e.get("angle.input.space")),s=e.get("angle.input.unitsCaseSensitive"),a=e.get("angle.units"),c=this.getAllAvailableUnits(),h=null,u=null;t=i.trim(t);for(var g=0;g<c.length;g++)if(c[g]in a)for(var m=a[c[g]],f=0;f<m.length;f++){var d=this.findUnit(t,m[f],s);null!==d&&(null===u||m[f].length>u.length)&&(h=c[g],u=m[f],r=d)}if(null!==h)t=i.trim(r);else{h=e.get("angle.defaultUnit");var p=!1;for(g=0;g<c.length;g++)if(c[g]===h){p=!0;break}p||(h=c[0])}var v=e.invokeParse(l,t);return C[h].call(C,v)};static findUnit=(t,e,n)=>{if(t.length<e.length)return null;var r=t.substr(t.length-e.length,e.length);return n||(e=e.toLowerCase(),r=r.toLowerCase()),e!==r?null:t.substr(0,t.length-e.length)};static toString=(t,e,n)=>{for(var r=this.getRealUnit(e.get("angle.output.unit"),!1),i=this.getRealUnit(e.get("angle.defaultUnit"),!0),s=null,a=this.getAllAvailableUnits(),o=0;o<a.length;o++)r===a[o]&&(s=t[r].call(t));null===s&&(s=t.deg());var c=e.invokeToString(l,s);return(e.get("angle.output.showDefaultUnit")||r!==i)&&(c+=e.get("angle.output.unitSeparator"),c+=this.getAngleOutputUnit(r,e)),c};static getAngleOutputUnit=(t,e)=>{var n=e.get("angle.units");return t in n?n[t][0]:t};static getRealUnit=(t,e)=>{for(var n=this.getAllAvailableUnits(),r=!1,i=0;i<n.length;i++)if(t===n[i]){r=!0;break}return r||(t=null),e||null!==t||(t=n[0]),t}}class A extends a{static getName=()=>"transformation";static accepts=t=>t instanceof b;static parse=(t,e,n)=>{var r=this.parseTransformationList(t,e);if(null===r)throw"Cannot parse transformation";return r=r.map((t=>{var n,r=k.getAtomicTransformationClassByType(t.type);if((n=t.canonical?r.getArgsConvertors():r.getNonCanonicalArgsConvertors()).length<t.args.length)throw"too much arguments when parsing transformation: "+t.type;for(var i,s=[],a=0;a<t.args.length;a++)s.push(e.invokeParse(n[a],t.args[a]));return(i=t.canonical?r.argsToParams(s):r.nonCanonicalArgsToParams(s)).type=t.type,k.instantiate(i)})),new b(r)};static parseTransformationList=(t,e)=>{var n=[];t=t.trim();for(var r,i,s,a=new o(e.get("transformation.input.space")),c=new o(e.get("transformation.input.identifier")),l=new o(e.get("transformation.input.transformationDelimeter")),h=new o(e.get("transformation.input.fieldDelimeter")),u=new o(e.get("transformation.input.nonCanonicalSuffix")),g=e.get("transformation.input.parenthesis").map((t=>new o(t))),m=!0;""!==t;){if(s={},!m){if((i=l.split2(t)).length<2)return null;if(""!==i[0]&&!a.matchAll(i[0]))return null;t=i[1]}if(m=!1,[r,t]=a.readToken(t),""===t)break;if([s.type,t]=c.readToken(t),null===s.type)return null;if([r,t]=a.readToken(t),[r,t]=u.readToken(t),null!==r?(s.canonical=!1,[r,t]=a.readToken(t)):s.canonical=!0,[r,t]=g[0].readToken(t),null===r)return null;if((i=g[1].split2(t)).length<2)return null;s.args=this.parseTransformationArgs(i[0],a,h),t=i[1],n.push(s)}return n};static parseTransformationArgs=(t,e,n)=>{var r=[],i=[t];do{i.length>1&&r.push(e.trim(i.shift())),t=e.trim(i.shift()),i=n.split2(t)}while(i.length>1);return r.push(e.trim(i.shift())),r};static atomicTransformationToString=(t,e)=>{var n,r,i=t.isCanonical();i?(n=t.getArgs(),r=t.getArgsConvertors()):(n=t.getNonCanonicalArgs(),r=t.getNonCanonicalArgsConvertors());for(var s=[],a=0;a<n.length;a++)s.push(e.invokeToString(r[a],n[a]));var o=e.get("transformation.output.fieldDelimeter"),c=e.get("transformation.output.parenthesis"),l=i?"":e.get("transformation.output.nonCanonicalSuffix");return t.getName()+l+c[0]+s.join(o)+c[1]};static toString=(t,e,n)=>{var r=this;return e.get("transformation.output.convertToCanonicalForm")&&(t=t.canonize()),t.getAtomicTransformations().map((t=>r.atomicTransformationToString(t,e))).join(e.get("transformation.output.transformationDelimeter"))}}let M={"angle.defaultUnit":"deg","angle.units":{deg:["deg"],rad:["rad"],grad:["grad"],turn:["turn"]},"angle.output.unit":"deg","angle.output.showDefaultUnit":!1,"angle.output.unitSeparator":"","angle.input.space":/\s+/,"angle.input.unitsCaseSensitive":!0,"number.output.precision":null,"number.output.outputZeroTrailingDecimals":!1,"number.input.space":/\s+/,"point.output.delimeter":", ","point.output.parenthesis":["[","]"],"point.input.space":/\s+/,"point.input.delimeter":/\s*[, ]\s*/,"point.input.parenthesis":[/[\[\(]?/,/[\]\)]?/],"vector.output.delimeter":", ","vector.output.parenthesis":["(",")"],"vector.input.space":/\s+/,"vector.input.delimeter":/\s*[, ]\s*/,"vector.input.parenthesis":[/[\[\(]?/,/[\]\)]?/],"transformation.output.transformationDelimeter":" ","transformation.output.fieldDelimeter":", ","transformation.output.parenthesis":["(",")"],"transformation.output.convertToCanonicalForm":!0,"transformation.output.nonCanonicalSuffix":"*","transformation.input.space":/\s+/,"transformation.input.identifier":/[a-zA-Z_][a-zA-Z0-9_]*/,"transformation.input.transformationDelimeter":/\s/,"transformation.input.fieldDelimeter":/\s*[,\s]\s*/,"transformation.input.nonCanonicalSuffix":"*","transformation.input.parenthesis":[/\s*\(/,")"],"fn.vector.parse":null,"fn.vector.toString":null,"fn.point.parse":null,"fn.point.toString":null,"fn.angle.parse":null,"fn.angle.toString":null,"fn.transformation.parse":null,"fn.transformation.toString":null};class X{static get=t=>t instanceof X?t:null==t?I:new X(I.params.merge(t));static setDefault=t=>{var e=I;return null===t&&(t=new X),I=t,e};constructor(t){void 0===t&&(t={}),t instanceof z||(t=new z(t)),this.params=t}setDefault=()=>X.setDefault(this);parseVector=t=>this.params.invokeParse(m,t);vectorToString=t=>this.params.invokeToString(m,t);parsePoint=t=>this.params.invokeParse(g,t);pointToString=t=>this.params.invokeToString(g,t);parseAngle=t=>this.params.invokeParse(x,t);angleToString=t=>this.params.invokeToString(x,t);parseTransformation=t=>this.params.invokeParse(A,t);transformationToString=t=>this.params.invokeToString(A,t)}class z{constructor(t){this._params=t}merge=t=>new z(Object.assign({},this._params,t));invokeParse=(t,e)=>{var n=this._getInvokedFunction(t,"parse")(e);if(!t.accepts(n))throw"Parser created an object which is not accepted by the convertor";return n};invokeToString=(t,e)=>{var n=this._getInvokedFunction(t,"toString");if(!t.accepts(e))throw"Convertor does not accept this object for toString conversion";return n(e)};get=t=>this._get(t);_getInvokedFunction=(t,e)=>{var n="fn."+t.getName()+"."+e,r=this.get(n),i=null,s=this;return null===r&&(r=t[e],i=t),t=>r.call(i,t,s,n)};_get=t=>t in this._params?this._params[t]:t in M?M[t]:null}var I=new X;class S{constructor(t,e){this.x=t,this.y=e,Object.freeze(this)}static create=(...e)=>{var n;if(n=t.args(e,"x:number","y:number"))return new S(n.x,n.y);if(n=t.args(e,["vector",S]))return n.vector;if(n=t.args(e,"string:string"))return X.get().parseVector(n.string);throw"Cannot construct vector from given arguments"};static zero=()=>new S(0,0);getTranslation=()=>b.translate(this);size=()=>Math.sqrt(this.mul(this));isZero=()=>i.isZero(this.x)&&i.isZero(this.y);mul=t=>{if("number"==typeof t)return new S(this.x*t,this.y*t);if(t instanceof S)return this.x*t.x+this.y*t.y;throw"invalid arguments"};add=t=>new S(this.x+t.x,this.y+t.y);sub=t=>new S(this.x-t.x,this.y-t.y);rot=t=>{var e=t.cos(),n=t.sin();return new S(e*this.x-n*this.y,n*this.x+e*this.y)};normalize=()=>{var t=this.size();return t>0?new S(this.x/t,this.y/t):S.zero()};angleTo=t=>{var e=Math.acos(this.mul(t)/(this.size()*t.size()));return this.x*t.y-this.y*t.x<0&&(e=2*Math.PI-e),C.rad(e)};toString=(...t)=>X.get.apply(X,t).vectorToString(this)}var Y=1;const N=(t,e,n,r)=>{if(e instanceof u)return e;if(e instanceof Function)return e(t,((t,e,n)=>t instanceof u?()=>n.universalToBodyCoords(e.bodyToUniversalCoords(t)):()=>{throw"cannot get opposite point"})(r,n,t));throw"Cannt evaluate invalid point definition"};class _{constructor(t,e,n,r){this.uniqid=Y++,this.body1=t,this.body2=n,this.point1=e,this.point2=r,Object.freeze(this)}getId(){return this.uniqid}getMyPoint(t){if(this.body1===t)return N(this.body1,this.point1,this.body2,this.point2);if(this.body2===t)return N(this.body2,this.point2,this.body1,this.point1);throw"Bug happened"}getOppositePoint(t){if(this.body1===t)return N(this.body2,this.point2,this.body1,this.point1);if(this.body2===t)return N(this.body1,this.point1,this.body2,this.point2);throw"Bug happened"}getOppositeBody(t){if(this.body1===t)return this.body2;if(this.body2===t)return this.body1;throw"Bug happened"}getOppositePointInMyCoords(t){const e=this.getOppositePoint(t),n=this.getOppositeBody(t);return t.universalToBodyCoords(n.bodyToUniversalCoords(e))}}class O{static zero(){return new O(0,S.zero())}constructor(t,e){this.momentum=t,this.vector=e,Object.freeze(this)}add=t=>new O(this.momentum+t.momentum,this.vector.add(t.vector));sub=t=>new O(this.momentum-t.momentum,this.vector.sub(t.vector));mul=(t,e=void 0)=>(null==e&&(e=t),new O(this.momentum*t,this.vector.mul(e)))}const V=(t,e)=>{var n=u.origin().vectorTo(e);const r=n.size(),i=(n=n.normalize()).rot(C.right()).mul(t)*r;return n.mul(n.mul(t)),new O(i,t)};class j{universalToBodyCoords=t=>t;bodyToUniversalCoords=t=>t}const F=new j;var Z=1;window.mech2d={Mechanics:class{constructor(){this.frictionCoeficient=1,this.tQuantum=.01,this.elasticityFactor=1,this.frictionFactor=1,this.maxVelocityAllowed=1e-4,this.maxAngularVelocityAllowed=1e-4,this.maxIterations=1e3,this.bodies={},this.recalcSpeeds()}addBody=t=>(this.bodies[t.getId()]=t,this.recalcSpeeds(),this);removeBody=t=>{delete this.bodies[t.getId()]};solve=()=>{for(var t=0;this.maxVelocity>this.maxVelocityAllowed||this.maxAngularVelocity>this.maxAngularVelocityAllowed;){if(null!==this.maxIterations&&void 0!==this.maxIterations&&t>=this.maxIterations)throw"maximum iterations reached";t++,this.iteration()}};iteration=()=>{for(var t in this.bodies){var e=(n=this.bodies[t]).getAllLinksForce(this.elasticityFactor);n.applyFriction(this.frictionFactor,this.tQuantum),n.applyForce(e,this.tQuantum)}for(var t in this.bodies){var n;(n=this.bodies[t]).move(this.tQuantum)}this.recalcSpeeds()};recalcSpeeds=()=>{for(var t in this.maxVelocity=0,this.maxAngularVelocity=0,this.bodies){var e=this.bodies[t];this.maxVelocity=Math.max(this.maxVelocity,e.velocity.size()),this.maxAngularVelocity=Math.max(this.maxAngularVelocity,e.angularVelocity.rad())}}},Body:class{constructor(t,e=1,n=1){this.id=Z++,this.mass=e,this.angularMomentum=n,this.track=u.origin().vectorTo(u.create(t)),this.velocity=S.zero(),this.angularTrack=C.zero(),this.angularVelocity=C.zero(),this.links={},this.updateCurrentTransformation()}getId=()=>this.id;updateCurrentTransformation=()=>{this.currentTransformation=b.translate(this.track).compose(b.rotate(this.angularTrack)),this.currentInverseTransformation=this.currentTransformation.inv()};universalToBodyCoords=t=>this.currentInverseTransformation.transform(t);bodyToUniversalCoords=t=>this.currentTransformation.transform(t);link=(t,e,n=void 0)=>{null==n&&(n=e),null==t&&(t=F),e instanceof u&&(e=this.universalToBodyCoords(e)),n instanceof u&&(n=t.universalToBodyCoords(n));const r=new _(this,e,t,n),i=r.getId();return this.links[i]=r,t instanceof j||(t.links[i]=r),r};unlink=t=>{const e=t.getId();e in this.links&&delete this.links[e];const n=t.getOppositeBody(this);return n instanceof j||delete n.links[e],this};move=t=>(this.track=this.track.add(this.velocity.mul(t)),this.angularTrack=this.angularTrack.add(this.angularVelocity.mul(t)),this.updateCurrentTransformation(),this);applyFriction=(t,e)=>{const n=Math.exp(-t*e);return this.velocity=this.velocity.mul(n),this.angularVelocity=this.angularVelocity.mul(n),this};getForce=(t,e)=>V(this.universalToBodyCoords(t),this.universalToBodyCoords(e));getLinkForce=(t,e=1)=>{if(!(t.getId()in this.links))return O.zero();const n=t.getMyPoint(this),r=t.getOppositePointInMyCoords(this);return V(n.vectorTo(r).mul(e),n)};getAllLinksForce=(t=1)=>{var e=null;for(var n in this.links){var r=this.links[n],i=this.getLinkForce(r,t);e=null===e?i:e.add(i)}return null===e&&(e=O.zero()),e};applyForce=(t,e)=>{var n=t.mul(e/this.angularMomentum,e/this.mass);return this.velocity=this.velocity.add(n.vector),this.angularVelocity=this.angularVelocity.add(C.rad(deltaVeloctiy.momentum)),this}}},window.eeg2d={Vector:S,Point:u,Angle:C,Transformation:b,StringConvertor:X}})();